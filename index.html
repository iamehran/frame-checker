<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Detection Frame Detector - Vibe Reel (Adjustable)</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-dark: #0a0e14;
            --bg-card: #151921;
            --bg-input: #1a1f2b;
            --accent-cyan: #00d9ff;
            --accent-green: #00ff9f;
            --accent-yellow: #ffd500;
            --accent-red: #ff3366;
            --text-primary: #e6e9ef;
            --text-secondary: #8b92a3;
            --border: #2a2f3a;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
        }
        
        .container { max-width: 1400px; margin: 0 auto; padding: 40px 20px; }
        .header { text-align: center; margin-bottom: 50px; }
        .logo { font-size: 14px; letter-spacing: 3px; color: var(--accent-cyan); margin-bottom: 10px; font-weight: 700; text-transform: uppercase; }
        h1 { font-size: 48px; font-weight: 700; margin-bottom: 15px; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-green)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { color: var(--text-secondary); font-size: 14px; }
        
        .upload-section {
            background: var(--bg-card);
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .upload-section:hover { border-color: var(--accent-cyan); }
        .upload-icon { font-size: 64px; margin-bottom: 20px; }
        .upload-text { font-size: 16px; margin-bottom: 10px; font-weight: 600; }
        
        .controls { display: flex; gap: 15px; margin: 30px 0; align-items: center; flex-wrap: wrap; }
        .control-group { flex: 1; min-width: 200px; }
        .control-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; }
        .time-input { width: 100%; padding: 12px 15px; background: var(--bg-input); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 14px; }
        
        .detect-btn { padding: 14px 40px; background: linear-gradient(135deg, var(--accent-cyan), var(--accent-green)); border: none; border-radius: 8px; color: var(--bg-dark); font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 700; cursor: pointer; text-transform: uppercase; }
        .detect-btn:disabled { opacity: 0.5; }
        
        .canvas-wrapper {
            position: relative;
            margin: 20px 0;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-card);
        }
        
        .video-canvas { 
            width: 100%; 
            display: block;
            cursor: crosshair;
        }
        
        .help-text {
            text-align: center;
            color: var(--accent-green);
            font-size: 13px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 255, 159, 0.1);
            border-radius: 8px;
        }
        
        .results-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 30px; }
        .participant-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
        .participant-id { font-size: 18px; font-weight: 700; color: var(--accent-cyan); margin-bottom: 15px; }
        .coord-value { font-size: 14px; color: var(--accent-green); margin: 8px 0; }
        
        .ffmpeg-command { background: var(--bg-input); border-radius: 8px; padding: 15px; margin-top: 15px; position: relative; }
        .ffmpeg-code { font-size: 12px; color: var(--accent-yellow); word-break: break-all; padding-right: 60px; }
        .copy-btn { position: absolute; top: 15px; right: 15px; padding: 6px 12px; background: var(--accent-cyan); color: var(--bg-dark); border: none; border-radius: 4px; cursor: pointer; font-size: 11px; }
        
        .loading { text-align: center; padding: 40px; color: var(--text-secondary); }
        .spinner { width: 40px; height: 40px; margin: 0 auto 20px; border: 3px solid var(--border); border-top-color: var(--accent-cyan); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        input[type="file"] { display: none; }
        
        .info-box {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        const COLORS = ['#00d9ff', '#00ff9f', '#ffd500', '#ff3366'];

        function App() {
            const [modelsLoaded, setModelsLoaded] = useState(false);
            const [video, setVideo] = useState(null);
            const [videoUrl, setVideoUrl] = useState(null);
            const [boxes, setBoxes] = useState([]);
            const [processing, setProcessing] = useState(false);
            const [seekTime, setSeekTime] = useState(10);
            const [dragging, setDragging] = useState(null);
            const [videoFrame, setVideoFrame] = useState(null);
            
            const fileInputRef = useRef(null);
            const videoRef = useRef(null);
            const canvasRef = useRef(null);

            useEffect(() => {
                loadModels();
            }, []);

            useEffect(() => {
                if (boxes.length > 0 && videoFrame) {
                    redrawCanvas();
                }
            }, [boxes, videoFrame]);

            const loadModels = async () => {
                try {
                    const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.12/model/';
                    await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
                    setModelsLoaded(true);
                } catch (error) {
                    console.error('Model load error:', error);
                }
            };

            const handleFileSelect = (file) => {
                if (file && file.type.startsWith('video/')) {
                    setVideo(file);
                    setVideoUrl(URL.createObjectURL(file));
                    setBoxes([]);
                }
            };

            const detectFaces = async () => {
                if (!videoRef.current || !canvasRef.current || !modelsLoaded) return;
                setProcessing(true);

                try {
                    const videoEl = videoRef.current;
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');

                    await new Promise((resolve) => {
                        if (videoEl.readyState >= 1) resolve();
                        else videoEl.onloadedmetadata = resolve;
                    });

                    const width = videoEl.videoWidth;
                    const height = videoEl.videoHeight;
                    canvas.width = width;
                    canvas.height = height;

                    videoEl.currentTime = Math.min(seekTime, videoEl.duration - 1);
                    await new Promise((resolve) => { videoEl.onseeked = resolve; });
                    await new Promise(resolve => setTimeout(resolve, 200));

                    ctx.drawImage(videoEl, 0, 0, width, height);
                    
                    // Store frame for redrawing
                    setVideoFrame(ctx.getImageData(0, 0, width, height));

                    const detections = await faceapi.detectAllFaces(
                        canvas,
                        new faceapi.TinyFaceDetectorOptions({ inputSize: 416, scoreThreshold: 0.3 })
                    );

                    if (detections.length === 0) {
                        alert('No faces detected. Try a different timestamp.');
                        setProcessing(false);
                        return;
                    }

                    // Sort by position
                    const faces = detections.map(d => {
                        const box = d.box;
                        return {
                            centerX: box.x + box.width / 2,
                            centerY: box.y + box.height / 2,
                            box: box
                        };
                    });

                    faces.sort((a, b) => {
                        if (Math.abs(a.centerY - b.centerY) < height * 0.3) {
                            return a.centerX - b.centerX;
                        }
                        return a.centerY - b.centerY;
                    });

                    // Determine grid
                    let gridCols, gridRows;
                    const count = faces.length;
                    
                    if (count === 2) {
                        const yDiff = Math.abs(faces[0].centerY - faces[1].centerY);
                        gridCols = yDiff < height * 0.3 ? 2 : 1;
                        gridRows = yDiff < height * 0.3 ? 1 : 2;
                    } else if (count <= 4) {
                        gridCols = 2; gridRows = 2;
                    } else {
                        gridCols = Math.ceil(Math.sqrt(count));
                        gridRows = Math.ceil(count / gridCols);
                    }

                    const cellWidth = width / gridCols;
                    const cellHeight = height / gridRows;

                    const initialBoxes = faces.map((face, index) => {
                        const col = Math.floor(face.centerX / cellWidth);
                        const row = Math.floor(face.centerY / cellHeight);

                        let cellX = col * cellWidth;
                        let cellY = row * cellHeight;
                        let cellW = cellWidth;
                        let cellH = cellHeight;

                        const padding = 20;
                        cellX += padding;
                        cellY += padding;
                        cellW -= padding * 2;
                        cellH -= padding * 2;

                        // Make square
                        let x = cellX;
                        let y = cellY;
                        let w = cellW > cellH ? cellH : cellW;
                        let h = w;

                        if (cellW > cellH) {
                            x = cellX + (cellW - w) / 2;
                        } else {
                            y = cellY + (cellH - h) / 2;
                        }

                        return {
                            id: index + 1,
                            x: Math.floor(x),
                            y: Math.floor(y),
                            width: Math.floor(w),
                            height: Math.floor(h),
                            color: COLORS[index % COLORS.length]
                        };
                    });

                    setBoxes(initialBoxes);
                    setProcessing(false);

                } catch (error) {
                    console.error('Detection error:', error);
                    alert('Detection failed: ' + error.message);
                    setProcessing(false);
                }
            };

            const redrawCanvas = () => {
                const canvas = canvasRef.current;
                if (!canvas || !videoFrame) return;
                
                const ctx = canvas.getContext('2d');
                
                // Redraw original frame
                ctx.putImageData(videoFrame, 0, 0);
                
                // Draw boxes
                boxes.forEach(box => {
                    // Box
                    ctx.strokeStyle = box.color;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(box.x, box.y, box.width, box.height);
                    
                    // Label
                    ctx.fillStyle = box.color;
                    ctx.font = 'bold 24px JetBrains Mono';
                    ctx.fillText(`P${box.id}`, box.x + 10, box.y + 35);
                    
                    // Resize handles (corners)
                    const handleSize = 12;
                    ctx.fillStyle = box.color;
                    
                    // Top-left
                    ctx.fillRect(box.x - handleSize/2, box.y - handleSize/2, handleSize, handleSize);
                    // Top-right
                    ctx.fillRect(box.x + box.width - handleSize/2, box.y - handleSize/2, handleSize, handleSize);
                    // Bottom-left
                    ctx.fillRect(box.x - handleSize/2, box.y + box.height - handleSize/2, handleSize, handleSize);
                    // Bottom-right
                    ctx.fillRect(box.x + box.width - handleSize/2, box.y + box.height - handleSize/2, handleSize, handleSize);
                });
            };

            const handleCanvasMouseDown = (e) => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                // Check if clicking on a box or handle
                for (let i = boxes.length - 1; i >= 0; i--) {
                    const box = boxes[i];
                    const handleSize = 12;
                    
                    // Check resize handles first
                    if (Math.abs(mouseX - box.x) < handleSize && Math.abs(mouseY - box.y) < handleSize) {
                        setDragging({ index: i, type: 'resize-tl' });
                        return;
                    }
                    if (Math.abs(mouseX - (box.x + box.width)) < handleSize && Math.abs(mouseY - box.y) < handleSize) {
                        setDragging({ index: i, type: 'resize-tr' });
                        return;
                    }
                    if (Math.abs(mouseX - box.x) < handleSize && Math.abs(mouseY - (box.y + box.height)) < handleSize) {
                        setDragging({ index: i, type: 'resize-bl' });
                        return;
                    }
                    if (Math.abs(mouseX - (box.x + box.width)) < handleSize && Math.abs(mouseY - (box.y + box.height)) < handleSize) {
                        setDragging({ index: i, type: 'resize-br' });
                        return;
                    }
                    
                    // Check if inside box for dragging
                    if (mouseX >= box.x && mouseX <= box.x + box.width &&
                        mouseY >= box.y && mouseY <= box.y + box.height) {
                        setDragging({ 
                            index: i, 
                            type: 'move',
                            startX: mouseX - box.x,
                            startY: mouseY - box.y
                        });
                        return;
                    }
                }
            };

            const handleCanvasMouseMove = (e) => {
                if (!dragging) return;
                
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                const newBoxes = [...boxes];
                const box = newBoxes[dragging.index];
                
                if (dragging.type === 'move') {
                    box.x = Math.max(0, Math.min(canvas.width - box.width, mouseX - dragging.startX));
                    box.y = Math.max(0, Math.min(canvas.height - box.height, mouseY - dragging.startY));
                } else if (dragging.type.startsWith('resize-')) {
                    const minSize = 50;
                    
                    if (dragging.type === 'resize-tl') {
                        const newWidth = box.x + box.width - mouseX;
                        const newHeight = box.y + box.height - mouseY;
                        if (newWidth > minSize && newHeight > minSize) {
                            box.x = mouseX;
                            box.y = mouseY;
                            box.width = newWidth;
                            box.height = newHeight;
                        }
                    } else if (dragging.type === 'resize-tr') {
                        const newWidth = mouseX - box.x;
                        const newHeight = box.y + box.height - mouseY;
                        if (newWidth > minSize && newHeight > minSize) {
                            box.y = mouseY;
                            box.width = newWidth;
                            box.height = newHeight;
                        }
                    } else if (dragging.type === 'resize-bl') {
                        const newWidth = box.x + box.width - mouseX;
                        const newHeight = mouseY - box.y;
                        if (newWidth > minSize && newHeight > minSize) {
                            box.x = mouseX;
                            box.width = newWidth;
                            box.height = newHeight;
                        }
                    } else if (dragging.type === 'resize-br') {
                        const newWidth = mouseX - box.x;
                        const newHeight = mouseY - box.y;
                        if (newWidth > minSize && newHeight > minSize) {
                            box.width = newWidth;
                            box.height = newHeight;
                        }
                    }
                }
                
                setBoxes(newBoxes);
            };

            const handleCanvasMouseUp = () => {
                setDragging(null);
            };

            return (
                <div className="container">
                    <div className="header">
                        <div className="logo">âš¡ VIBE REEL</div>
                        <h1>Adjustable Frame Detector</h1>
                        <div className="subtitle">Detect faces, then drag & resize crop boxes to perfect positions</div>
                    </div>

                    {!modelsLoaded && <div className="loading"><div className="spinner"></div>Loading models...</div>}

                    {modelsLoaded && !video && (
                        <>
                            <div className="info-box">
                                <strong>ðŸŽ¯ How it works:</strong><br/>
                                1. Upload video â†’ Detect faces automatically<br/>
                                2. Drag boxes to reposition | Drag corners to resize<br/>
                                3. Get exact FFmpeg crop coordinates<br/>
                                4. Stack squares for Instagram Reels
                            </div>
                            
                            <div className="upload-section" onClick={() => fileInputRef.current.click()}>
                                <div className="upload-icon">ðŸŽ¥</div>
                                <div className="upload-text">Upload Google Meet Recording</div>
                                <input ref={fileInputRef} type="file" accept="video/*" onChange={(e) => handleFileSelect(e.target.files[0])} />
                            </div>
                        </>
                    )}

                    {video && (
                        <>
                            <div className="controls">
                                <div className="control-group">
                                    <div className="control-label">Timestamp (seconds)</div>
                                    <input 
                                        type="number" 
                                        className="time-input" 
                                        value={seekTime} 
                                        onChange={(e) => setSeekTime(Number(e.target.value))} 
                                        min="0" 
                                    />
                                </div>
                                <button className="detect-btn" onClick={detectFaces} disabled={processing}>
                                    {processing ? 'Detecting...' : 'Detect Faces'}
                                </button>
                            </div>

                            <video ref={videoRef} src={videoUrl} style={{display: 'none'}} />
                            
                            <div className="canvas-wrapper">
                                <canvas 
                                    ref={canvasRef} 
                                    className="video-canvas"
                                    onMouseDown={handleCanvasMouseDown}
                                    onMouseMove={handleCanvasMouseMove}
                                    onMouseUp={handleCanvasMouseUp}
                                    onMouseLeave={handleCanvasMouseUp}
                                />
                            </div>
                            
                            {boxes.length > 0 && (
                                <div className="help-text">
                                    âœ¨ Drag boxes to move | Drag corners to resize | Updates FFmpeg commands live
                                </div>
                            )}

                            {boxes.length > 0 && (
                                <div className="results-grid">
                                    {boxes.map(box => (
                                        <div key={box.id} className="participant-card">
                                            <div className="participant-id">Participant {box.id}</div>
                                            <div className="coord-value">Position: ({box.x}, {box.y})</div>
                                            <div className="coord-value">Size: {box.width} Ã— {box.height}</div>
                                            <div className="coord-value">crop={box.width}:{box.height}:{box.x}:{box.y}</div>
                                            <div className="ffmpeg-command">
                                                <div className="ffmpeg-code">
                                                    ffmpeg -i input.mp4 -vf "crop={box.width}:{box.height}:{box.x}:{box.y}" -c:v libx264 -preset fast -crf 23 -c:a copy participant_{box.id}.mp4
                                                </div>
                                                <button 
                                                    className="copy-btn" 
                                                    onClick={() => navigator.clipboard.writeText(
                                                        `ffmpeg -i input.mp4 -vf "crop=${box.width}:${box.height}:${box.x}:${box.y}" -c:v libx264 -preset fast -crf 23 -c:a copy participant_${box.id}.mp4`
                                                    )}
                                                >
                                                    Copy
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                    
                                    {boxes.length > 1 && (
                                        <div className="participant-card" style={{gridColumn: '1 / -1', background: 'var(--bg-input)'}}>
                                            <div className="participant-id" style={{color: 'var(--accent-green)'}}>
                                                ðŸ“š Stack All Squares Vertically
                                            </div>
                                            <div className="ffmpeg-command">
                                                <div className="ffmpeg-code">
                                                    ffmpeg {boxes.map((_, i) => `-i participant_${i + 1}.mp4`).join(' ')} -filter_complex "{boxes.map((_, i) => `[${i}:v]`).join('')}vstack=inputs={boxes.length}[v]" -map "[v]" -c:v libx264 -preset fast -crf 23 stacked_output.mp4
                                                </div>
                                                <button 
                                                    className="copy-btn" 
                                                    onClick={() => navigator.clipboard.writeText(
                                                        `ffmpeg ${boxes.map((_, i) => `-i participant_${i + 1}.mp4`).join(' ')} -filter_complex "${boxes.map((_, i) => `[${i}:v]`).join('')}vstack=inputs=${boxes.length}[v]" -map "[v]" -c:v libx264 -preset fast -crf 23 stacked_output.mp4`
                                                    )}
                                                >
                                                    Copy
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}
                        </>
                    )}
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>

